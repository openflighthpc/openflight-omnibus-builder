#!/bin/bash
#==============================================================================
# Copyright (C) 2019-present Alces Flight Ltd.
#
# This file is part of Alces Flight Omnibus Builder.
#
# This program and the accompanying materials are made available under
# the terms of the Eclipse Public License 2.0 which is available at
# <https://www.eclipse.org/legal/epl-2.0>, or alternative license
# terms made available by Alces Flight Ltd - please direct inquiries
# about licensing to licensing@alces-flight.com.
#
# This project is distributed in the hope that it will be useful, but
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR
# IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS
# OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. See the Eclipse Public License 2.0 for more
# details.
#
# You should have received a copy of the Eclipse Public License 2.0
# along with this project. If not, see:
#
#  https://opensource.org/licenses/EPL-2.0
#
# For more information on Alces Flight Omnibus Builder, please visit:
# https://github.com/alces-flight/alces-flight-omnibus-builder
#===============================================================================
set -e

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
CERT_DIR=$(mktemp -d /tmp/flight-www-certs.XXXXXX)

clean_up() {
  rm -rf "${CERT_DIR}"
}
trap clean_up EXIT

assert_user_is_root() {
    if [[ "$( id -u )" != "0" ]] ; then
        echo "Must be root to run this script" >&2
        exit 1
    fi
}

format() {
    local columns=${COLUMNS:-`tput cols 2>&-||echo 80`}
    if [ type fmt 1>/dev/null 2>/dev/null ] ; then
        echo -e "$@" | fmt -w ${columns}
    else
        echo -e "$@"
    fi
}

create_private_key() {
    format "We will now step you through generating self-signed certificates that are" \
        "valid for 10 years."
    format "You will be asked to enter a passphrase and to provide details" \
        "about your organization.\n"

    mkdir -p "${CERT_DIR}"
    cd "${CERT_DIR}"
    openssl req -new > "${CERT_DIR}"/cert.csr
    cd - 1>/dev/null
}

create_certs() {
    format "\nWe will now generate a public key.  You will be asked to enter" \
        "the passphrase you provided earlier.\n"

    openssl rsa -in "${CERT_DIR}"/privkey.pem -out "${CERT_DIR}"/key.pem
    openssl x509 -in "${CERT_DIR}"/cert.csr \
        -out "${CERT_DIR}"/cert.pem \
        -req \
        -signkey "${CERT_DIR}"/key.pem \
        -days 3650
    cat "${CERT_DIR}"/key.pem >> "${CERT_DIR}"/cert.pem
}


install_certs() {
    mkdir -p "${flight_ROOT}"/etc/www/ssl
    rm -f "${flight_ROOT}"/etc/www/ssl/fullchain.pem "${flight_ROOT}"/etc/www/ssl/key.pem
    cp "${CERT_DIR}"/cert.pem "${flight_ROOT}"/etc/www/ssl/fullchain.pem
    cp "${CERT_DIR}"/key.pem "${flight_ROOT}"/etc/www/ssl/key.pem
}

reload_www_service() {
    "${flight_ROOT}"/bin/flight service restart www || true
}

enable_https() {
    bootstrap_self_signed
    mv "${flight_ROOT}"/etc/www/http.d/https.conf{.disabled,}
    reload_www_service
}

disable_https() {
    mv "${flight_ROOT}"/etc/www/http.d/https.conf{,.disabled}
    reload_www_service
}

usage() {
    local prog
    prog="flight www"
    cat <<DOC
USAGE:

${prog} cert-gen|cron-renewal|enable-https|disable-https

DESCRIPTION:
The embedded nginx server ships with HTTP support and can be started using the
'flight service start www' command.

The '$prog' utilites are used to manage HTTPS support. By default the
HTTPS server is disabled as it requires an SSL certificate. It is strongly
recommended that a LetsEncrypt certificate is generated for HTTPS.

You will require a publicly available DNS entry and an email address before a
LetsEncrypt certificate can be issued. The HTTP server also needs running so
LetsEncrypt can preform the DNS challenge.

The SSL certificate are generated using the '$prog cert-gen' command.
The following command will generate a LetsEncrypt certificate:
'$prog cert-gen --cert-type lets-encrypt --domain DOMAIN --email EMAIL'

Once the LetsEncrypt certificate has been generated it will need to be
periodically renewed. This process can be automated by running:
'$prog cron-renewal'

Finally the HTTPS server is ready to be enabled:
'$prog enable-https'

Alternatively HTTPS can be enabled using an self-signed SSL certificate.
This is not recommended as its inheritly insecure. Run the following to
generate a self-signed certificate:
'$prog cert-gen --cert-type self-signed'

Self signed certificates are valid for 10 years and therefore automatic
renewal is not supported. The HTTPS server will still need to be enabled.
DOC
}

# Will auto generate a self signed certificate if required
bootstrap_self_signed() {
    if [ ! -f "${flight_ROOT}/etc/www/ssl/fullchain.pem" ]; then
        format "In order to enable HTTPs a set of SSL certificates need to be generated."
        format "Please see 'flight cert-gen --help' on how to generate certificates with LetsEncrypt."
        format "\nStarting SSL certificate generation..."
        # Slows down the CLI to prevent the user from being bombarded with text
        sleep 1
        create_private_key
        create_certs
        install_certs
    fi
}

# NOTE: The __* commands are not part of the public interface and are solely
#       used for wrapping purposes. They maybe changed/removed without warning.
#       They intentionally do not appear in the usage
main() {
    assert_user_is_root

    case "$1" in
        enable-https)
            shift
            enable_https "${@}"
            ;;

        disable-https)
            shift
            disable_https "${@}"
          ;;
        __create_self_signed)
            shift
            create_private_key
            create_certs
            install_certs
            ;;
        cert-gen)
            shift
            clean_up
            exec $flight_ROOT/bin/flexec ruby $DIR/cert "$@"
            ;;
        cron-renewal)
            shift
            clean_up
            exec $flight_ROOT/bin/flexec ruby $DIR/cron "$@"
            ;;
        --help | help)
            usage
            exit 0
            ;;

        *)
            usage
            exit 2
            ;;
    esac
}


if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
