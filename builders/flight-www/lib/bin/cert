#!/usr/bin/env ruby
#==============================================================================
# Copyright (C) 2019-present Alces Flight Ltd.
#
# This file is part of Alces Flight Omnibus Builder.
#
# This program and the accompanying materials are made available under
# the terms of the Eclipse Public License 2.0 which is available at
# <https://www.eclipse.org/legal/epl-2.0>, or alternative license
# terms made available by Alces Flight Ltd - please direct inquiries
# about licensing to licensing@alces-flight.com.
#
# This project is distributed in the hope that it will be useful, but
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR
# IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS
# OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. See the Eclipse Public License 2.0 for more
# details.
#
# You should have received a copy of the Eclipse Public License 2.0
# along with this project. If not, see:
#
#  https://opensource.org/licenses/EPL-2.0
#
# For more information on Alces Flight Omnibus Builder, please visit:
# https://github.com/alces-flight/alces-flight-omnibus-builder
#===============================================================================

# Require the default gems
ENV['BUNDLE_GEMFILE'] ||= File.join(__dir__, '../Gemfile')
require 'rubygems'
require 'bundler'
Bundler.require(:default)

require 'fileutils'
require 'yaml'
require 'ostruct'

class CertWWW < Hashie::Dash
  include Hashie::Extensions::IgnoreUndeclared

  def self.root_join(*a)
    File.join(ENV['flight_ROOT'] || raise('Missing flight_ROOT!') , *a)
  end

  HTTPS_SCRIPT = File.join(__dir__, 'https')
  SSL_DIR = root_join('etc/www/ssl')
  CONFIG_PATH = root_join('etc/cert-gen.yaml')

  def self.slop
    @slop ||= Slop::Options.new.tap do |s|
      s.bool '--lets-encrypt', 'Enable certificates with LetsEncrypt'
      s.bool '--self-signed', 'Enable self signed certificates'
      s.string '--domain', 'The domain associated with the LetsEncrypt certificate'
      s.bool '--auto', 'Enable automatic LetsEncrypt certificate renewal'
      s.bool '--manual', 'Disable automatic LetsEncrypt certificate renewal'
      s.bool '--config-only', 'Only update the internal configuration, skips certificate generation'
      s.on '--help', '-h', 'Display this help output' do
        $stderr.puts s
        exit
      end
    end
  end

  def self.run(*argv)
    parser = slop.parser.tap(&:reset)
    results = parser.parse(argv)
    new(OpenStruct.new results.to_h).run
  rescue Interrupt
    $stderr.puts 'Received Interrupt!'
    exit 130
  end

  def self.run_certbot(domain)
    system([
      "sudo certbot certonly --nginx",
      "#{'-n' unless $stdout.tty?}",
      "--nginx-ctl #{root_join('opt/www/embedded/sbin/nginx')}",
      "--nginx-server-root #{root_join('/etc/www')}",
      "--config-dir #{root_join('etc/letsencrypt')}",
      "--domain #{domain}"
    ].join(' '))
  end

  property :letsencrypt_domain
  property :cert_type
  property :cron
  property :config_only

  def initialize(slop)
    # Create the initial config object
    config = if File.exists? CONFIG_PATH
      OpenStruct.new YAML.load(File.read(CONFIG_PATH), symbolize_names: true)
    else
      OpenStruct.new
    end

    # Updates the cert_type + sanity check
    if slop.self_signed && slop.lets_encrypt
      $stderr.puts <<~ERROR.chomp
        Can not use --self-signed with --lets-encrypt
      ERROR
      exit 1
    elsif slop.self_signed
      config.cert_type = 'self_signed'
    elsif slop.lets_encrypt || (config.cert_type != 'self_signed')
      config.cert_type = 'lets_encrypt'
    end

    # Update the domain + sanity check
    if slop.domain && slop.self_signed
      $stderr.puts <<~ERROR.chomp
        Can not use --self-signed with --domain
      ERROR
      exit 1
    elsif slop.domain
      config.letsencrypt_domain = slop.domain
    end

    # Update cron + sanity check
    if slop.manual && slop.auto
      $stderr.puts 'Can not use --auto with --manual'
      exit 1
    elsif slop.auto
      config.cron = true
    elsif slop.manual
      config.cron = false
    end

    # Ensure the final configured config is valid
    if config.cert_type == 'self_signed' && config.cron
      $stderr.puts <<~ERROR.chomp
        Automatic renewal of self signed is unsupported!
        Please try again with the following flag: --manual
      ERROR
      exit 1
    elsif config.cert_type == 'lets_encrypt' && config.letsencrypt_domain.nil?
      $stderr.puts <<~ERROR.chomp
        LetsEncrypt certificates require a domain!
        Please try again with the following flags: --lets-encrypt --domain YOUR_DOMAIN
      ERROR
      exit 1
    end

    # Updates the crontab based on the config
    if config.cron
      File.write cron_path, <<~CRON
        #!/bin/bash
        #{self.class.root_join('bin/flexec')} ruby #{File.expand_path(__FILE__)}
      CRON
    else
      FileUtils.rm_f cron_path
    end

    # Saves the new config
    File.write CONFIG_PATH, YAML.dump(config.to_h)

    # Generates the underlining DASH
    super(config_only: slop.config_only, **config.to_h)
  end

  def run
    unless config_only
      generate_certificates
      restart_service
      puts
    end

    if cron
      puts "Your certificate will be automatically renewed close to its expiry"
    elsif cert_type == 'lets_encrypt'
      $stderr.puts <<~ERROR
        Currently your certificate will not be renewed when it expires!
        Automatic renewal can be enabled with: --auto --config-only
      ERROR
    end
  end

  def letsencrypt_fullchain
    self.class.root_join('etc/letsencrypt/live', letsencrypt_domain, 'fullchain.pem')
  end

  def letsencrypt_privkey
    self.class.root_join('etc/letsencrypt/live', letsencrypt_domain, 'privkey.pem')
  end

  def generate_certificates
    if cert_type == 'self_signed'
      system("#{HTTPS_SCRIPT} __create_self_signed")
    else
      self.class.run_certbot(letsencrypt_domain)
      FileUtils.mkdir_p SSL_DIR
      FileUtils.ln_sf letsencrypt_fullchain, File.join(SSL_DIR, 'fullchain.pem')
      FileUtils.ln_sf letsencrypt_privkey, File.join(SSL_DIR, 'key.pem') # NOTE: Intentionally key.pem not privkey.pem
    end
  end

  def cron_path
    self.class.root_join('etc/cron/daily/renew-ssl-cert')
  end

  def restart_service
    system("#{self.class.root_join('bin/flexec')} flight service restart www")
  end
end

Bundler.with_unbundled_env do
  CertWWW.run(*ARGV)
end

