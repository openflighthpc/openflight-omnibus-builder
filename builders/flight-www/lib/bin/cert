#!/usr/bin/env ruby
#==============================================================================
# Copyright (C) 2019-present Alces Flight Ltd.
#
# This file is part of Alces Flight Omnibus Builder.
#
# This program and the accompanying materials are made available under
# the terms of the Eclipse Public License 2.0 which is available at
# <https://www.eclipse.org/legal/epl-2.0>, or alternative license
# terms made available by Alces Flight Ltd - please direct inquiries
# about licensing to licensing@alces-flight.com.
#
# This project is distributed in the hope that it will be useful, but
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR
# IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS
# OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. See the Eclipse Public License 2.0 for more
# details.
#
# You should have received a copy of the Eclipse Public License 2.0
# along with this project. If not, see:
#
#  https://opensource.org/licenses/EPL-2.0
#
# For more information on Alces Flight Omnibus Builder, please visit:
# https://github.com/alces-flight/alces-flight-omnibus-builder
#===============================================================================

# Require the default gems
ENV['BUNDLE_GEMFILE'] ||= File.join(__dir__, '../Gemfile')
require 'rubygems'
require 'bundler'
Bundler.require(:default)

require 'fileutils'
require 'yaml'

class CertWWW < Hashie::Dash
  def self.root_join(*a)
    File.join(ENV['flight_ROOT'] || raise('Missing flight_ROOT!') , *a)
  end

  class Config < Hashie::Dash
    PATH = CertWWW.root_join('etc/cert-gen.yaml')

    def self.read
      if File.exists? PATH
        new YAML.load(File.read(PATH), symbolize_names: true)
      else
        new
      end
    end

    property :letsencrypt_domain
    property :cert_type

    def write
      File.write(PATH, YAML.dump(self.to_h))
    end
  end

  HTTPS_SCRIPT = File.join(__dir__, 'https')
  SSL_DIR = root_join('etc/www/ssl')

  def self.slop
    @slop ||= Slop::Options.new.tap do |s|
      s.bool '--self-signed', 'Enable self signed certificates'
      s.bool '--lets-encrypt', 'Enable certificates with LetsEncrypt'
      s.string '--domain', 'The domain associated with the LetsEncrypt certificate'
      s.bool '--manual', 'Disable automatic LetsEncrypt certificate renewal'
      s.bool '--auto', 'Enable automatic LetsEncrypt certificate renewal'
      s.bool '--skip-cert', 'Do not generate a new certificate'
      s.bool '--skip-restart', 'Do not restart the service'
      s.on '--help', '-h', 'Display the help output' do
        $stderr.puts s
        exit
      end
    end
  end

  def self.run(*argv)
    parser = slop.parser.tap(&:reset)
    results = parser.parse(argv)
    new(**results.to_h).run
  rescue Interrupt
    $stderr.puts 'Received Interrupt!'
    exit 130
  end

  def self.run_certbot(domain)
    system([
      "sudo certbot certonly --nginx",
      "#{'-n' unless $stdout.tty?}",
      "--nginx-ctl #{root_join('opt/www/embedded/sbin/nginx')}",
      "--nginx-server-root #{root_join('/etc/www')}",
      "--config-dir #{root_join('etc/letsencrypt')}",
      "--domain #{domain}"
    ].join(' '))
  end

  property :self_signed
  property :lets_encrypt
  property :auto
  property :manual
  property :domain
  property :skip_cert
  property :skip_restart

  attr_reader :cert_type, :letsencrypt_domain

  def initialize(**_)
    # Run the base initializer + variable plus local variable definitions
    super
    config = Config.read
    save = false

    # Populate the cert_type from the config + sanity check
    if self_signed && lets_encrypt
      $stderr.puts <<~ERROR.chomp
        Can not use --self-signed with --lets-encrypt
      ERROR
      exit 1
    elsif self_signed
      save = true
      @cert_type = config.cert_type = 'self_signed'
    elsif lets_encrypt
      save = true
      @cert_type = config.cert_type = 'lets_encrypt'
    elsif config.cert_type
      @cert_type = config.cert_type
    else
      save = true
      @cert_type = config.cert_type = 'lets_encrypt'
    end

    # Populate the domain + sanity check
    if domain
      save = true
      @letsencrypt_domain = config.letsencrypt_domain = domain
    elsif config.letsencrypt_domain && cert_type == 'lets_encrypt'
      @letsencrypt_domain = config.letsencrypt_domain
      puts "Using cached domain: #{letsencrypt_domain}"
    elsif cert_type == 'lets_encrypt'
      $stderr.puts <<~ERROR.chomp
        A domain is required when using LetsEncrypt!
        Either supply it with --domain DOMAIN or enable self signed certificates with --self-signed
      ERROR
      exit 1
    end

    # Prevents --auto/--manual and self signed from being used in weird combos
    if manual && auto
      $stderr.puts 'Can not use --auto with --manual'
      exit 1
    end
    if auto && (cert_type == 'self_signed')
      $stderr.puts 'Auto renewal of self signed certificates is not supported'
      exit 1
    end

    # Force manual renewal when switching to self-signed
    self.manual = true if self_signed

    config.write if save
  end

  def run
    generate_certificates unless skip_cert
    process_auto_renewal_flags
    restart_service unless skip_restart
  end

  def letsencrypt_fullchain
    self.class.root_join('etc/letsencrypt/live', letsencrypt_domain, 'fullchain.pem')
  end

  def letsencrypt_privkey
    self.class.root_join('etc/letsencrypt/live', letsencrypt_domain, 'privkey.pem')
  end

  def generate_certificates
    if cert_type == 'self_signed'
      system("#{HTTPS_SCRIPT} __create_self_signed")
    else
      self.class.run_certbot(letsencrypt_domain)
      FileUtils.mkdir_p SSL_DIR
      FileUtils.ln_sf letsencrypt_fullchain, File.join(SSL_DIR, 'fullchain.pem')
      FileUtils.ln_sf letsencrypt_privkey, File.join(SSL_DIR, 'key.pem') # NOTE: Intentionally key.pem not privkey.pem
    end
  end

  def process_auto_renewal_flags
    if auto
      puts 'Your certificate will be automatically renewed close to its expiry'
      File.write cron_path, <<~CRON
        #!/bin/bash
        #{self.class.root_join('bin/flexec')} ruby #{File.expand_path(__FILE__)}
      CRON
    elsif manual && File.exists?(cron_path)
      puts 'Your certificiate will no longer be automatically renewed'
      FileUtils.rm cron_path
    end
  end

  def cron_path
    self.class.root_join('etc/cron/daily/renew-ssl-cert')
  end

  def restart_service
    system("#{self.class.root_join('bin/flexec')} flight service restart www")
  end
end

Bundler.with_unbundled_env do
  CertWWW.run(*ARGV)
end

