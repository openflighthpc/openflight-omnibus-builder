#!/usr/bin/env ruby
#==============================================================================
# Copyright (C) 2019-present Alces Flight Ltd.
#
# This file is part of Alces Flight Omnibus Builder.
#
# This program and the accompanying materials are made available under
# the terms of the Eclipse Public License 2.0 which is available at
# <https://www.eclipse.org/legal/epl-2.0>, or alternative license
# terms made available by Alces Flight Ltd - please direct inquiries
# about licensing to licensing@alces-flight.com.
#
# This project is distributed in the hope that it will be useful, but
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR
# IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS
# OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. See the Eclipse Public License 2.0 for more
# details.
#
# You should have received a copy of the Eclipse Public License 2.0
# along with this project. If not, see:
#
#  https://opensource.org/licenses/EPL-2.0
#
# For more information on Alces Flight Omnibus Builder, please visit:
# https://github.com/alces-flight/alces-flight-omnibus-builder
#===============================================================================

# Require the default gems
ENV['BUNDLE_GEMFILE'] ||= File.join(__dir__, '../Gemfile')
require 'rubygems'
require 'bundler'
Bundler.require(:default)

require 'forwardable'
require 'ostruct'
require 'open3'
require 'openssl'

require_relative '../lib/shared'

module FlightWWW
  SelfSigned = Struct.new(:domain, :email) do
    def key
      @key ||= OpenSSL::PKey::RSA.new(2048)
    end

    def subject
      "/CN=#{domain}".tap do |str|
        str << "/emailAddress=#{email}" if email
      end
    end

    def certificate
      @certificate ||= OpenSSL::X509::Certificate.new.tap do |cert|
        cert.subject = cert.issuer = OpenSSL::X509::Name.parse(subject)
        cert.not_before = Time.now
        cert.not_after = Time.now + (10 * 365.25 * 24 * 60 * 60).to_i # Valid for 10 years
        cert.public_key = key.public_key
        cert.serial = rand(2**(8*20)-1)
        cert.version = 2

        ef = OpenSSL::X509::ExtensionFactory.new
        ef.subject_certificate = cert
        ef.issuer_certificate = cert
        cert.add_extension ef.create_extension("basicConstraints","CA:TRUE")
        cert.add_extension ef.create_extension("subjectKeyIdentifier", "hash")
        cert.add_extension ef.create_extension("authorityKeyIdentifier", "keyid:always,issuer:always")
        cert.add_extension ef.create_extension("keyUsage","keyCertSign, cRLSign" )

        cert.sign key, OpenSSL::Digest::SHA256.new
      end
    end

    def to_fullchain
      <<~PEM
        #{certificate.to_pem.chomp}
        #{key.to_s}
      PEM
    end
  end

  class CertCLI
    extend Forwardable

    def self.root_join(*a)
      Config.root_join(*a)
    end

    HTTPS_SCRIPT = File.join(__dir__, 'https')
    SSL_DIR = root_join('etc/www/ssl')
    SSL_FULLCHAIN = File.join(SSL_DIR, 'fullchain.pem')
    SSL_PRIVKEY = File.join(SSL_DIR, 'key.pem')
    CLI_CERT_TYPES = ['self-signed', 'lets-encrypt'].map do |type|
                       [type, type.sub('-', '_')]
                     end.flatten
    NGINX_BIN = root_join('opt/www/embedded/sbin/nginx')
    NGINX_ROOT = root_join('etc/www')
    LETSENCRYPT_CONFIG_DIR = root_join('etc/letsencrypt')
    LETSENCRYPT_LOG_DIR = root_join('var/log/letsencrypt')
    LETSENCRYPT_WORK_DIR = root_join('var/lib/letsencrypt')
    FLIGHT = root_join('bin/flight')
    HTTPS_CONFIG = root_join('etc/www/http.d/https.conf')
    CERTBOT_BIN = root_join('opt/certbot/bin/certbot')

    def self.slop
      @slop ||= Slop::Options.new(suppress_errors: true).tap do |s|
        s.string '--cert-type', 'Select the certificate type: lets-encrypt|self-signed'
        s.string '--domain', 'The domain associated with the LetsEncrypt certificate'
        s.string '--email', 'The email address associated with the LetsEncrypt certificate'
        s.bool '--config-only', 'Only update the internal configuration, skips certificate generation'
        s.on '--help', '-h', 'Display this help output' do
          $stderr.puts s
          exit
        end
      end
    end

    def self.run(*argv)
      parser = slop.parser.tap(&:reset)
      results = parser.parse(argv)
      os = OpenStruct.new(results.to_h)
      new(os).tap do |cli|
        cli.run unless os.config_only
      end
    rescue Interrupt
      $stderr.puts 'Received Interrupt!'
      exit 130
    end

    attr_reader :config
    def_delegators :@config, :domain, :email, :lets_encrypt?, :self_signed?

    def initialize(slop)
      Config.update do |config|
        @config = config

        # Updates the cert_type + sanity check
        if CLI_CERT_TYPES.include?(slop.cert_type)
          config.cert_type = slop.cert_type
        elsif slop.cert_type
          $stderr.puts <<~ERROR.chomp
            Unrecognized certificate type: #{slop.cert_type}
            Please select either: lets-encrypt or self-signed
          ERROR
          exit 1
        elsif config.cert_type?
          # noop
        else
          # Default the command to LetsEncrypt
          $stderr.puts <<~WARN.chomp
            Defaulting to LetsEncrypt
          WARN
          config.cert_type = 'lets_encrypt'
        end

        # Sets the domain and email if provided from the CLI
        config.email = slop.email if slop.email
        config.domain = slop.domain if slop.domain

        # Ensures the --domain and --email flags are provided (if required)
        # They maybe already specified in the config and self-signed certs do not require an email
        required_flags = if lets_encrypt?
                           [:domain, :email]
                         else
                           [:domain]
                         end
        missing_flags = required_flags.reject { |f| config.send(f) }
        unless missing_flags.empty?
          type = lets_encrypt? ? 'LetsEncrypt' : 'Self Signed'
          if missing_flags.length == 1
            name = missing_flags.first
            prep = (name == :domain) ? 'a domain' : 'an email'
            flag = "flag: --#{name} #{name.upcase}"
          else
            prep = 'a domain and email'
            flag = "flags: --domain DOMAIN --email EMAIL"
          end
          $stderr.puts <<~ERROR.chomp
            #{type} certificate can not be generated without #{prep}
            Please provide the following #{flag}
          ERROR
          exit 1
        end
      end
    end

    def run
      if self_signed?
        puts "Generating a Self Signed certificate with a 10 year expiry. Please wait..."
        builder = SelfSigned.new(domain, email)
        File.write SSL_FULLCHAIN, builder.to_fullchain
        File.write SSL_PRIVKEY, builder.key.to_s
      else
        run_certbot
      end

      # Restart the service!
      if File.exists? HTTPS_CONFIG
        system(FLIGHT, 'service', 'restart', 'www')
      else
        $stderr.puts <<~WARN.chomp
          The https server is currently disabled! It can be enabled with
          #{FLIGHT} www enable-https
        WARN
      end
    end

    def letsencrypt_fullchain
      self.class.root_join('etc/letsencrypt/live', domain, 'fullchain.pem')
    end

    def letsencrypt_privkey
      self.class.root_join('etc/letsencrypt/live', domain, 'privkey.pem')
    end

    def run_certbot
      stdout, _e, _s = Open3.capture3(FLIGHT, 'service', 'status', 'www')
      unless stdout.include?('active')
        $stderr.puts <<~ERROR.chomp
          The www service does not appear to be running, please start it and try again:
          #{FLIGHT} service start www
        ERROR
        exit 1
      end

      puts 'Generating a LetsEncrypt certificate, please wait...'
      _, error, status = Open3.capture3(CERTBOT_BIN, 'certonly', '-n', '--nginx',
        '--domain', domain, '--email', email, '--agree-tos',
        '--nginx-ctl', NGINX_BIN, '--nginx-server-root', NGINX_ROOT,
        '--config-dir', LETSENCRYPT_CONFIG_DIR, '--logs-dir', LETSENCRYPT_LOG_DIR,
        '--work-dir', LETSENCRYPT_WORK_DIR
      )

      # Rebuild the links and restart the service if required
      # NOTE: If the domain has been previously used it *may* still be in certbot's cache
      #       This means certbot *may* not regenerate the certificate
      #       However the service still needs updating if the domain has changed
      if status.success?
        FileUtils.mkdir_p SSL_DIR
        FileUtils.ln_sf letsencrypt_fullchain, SSL_FULLCHAIN
        FileUtils.ln_sf letsencrypt_privkey, SSL_PRIVKEY
      # Report to the user some other error has occurred
      else
        $stderr.puts <<~ERROR
          Failed to generate the LetsEncrypt certificate with the following error:

          #{error}
        ERROR
        exit 1
      end
    end
  end
end

Bundler.with_unbundled_env do
  FlightWWW::CertCLI.run(*ARGV)
end

